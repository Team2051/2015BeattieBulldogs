// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2051.RecycleRush.subsystems;

import org.usfirst.frc2051.RecycleRush.Robot;
import org.usfirst.frc2051.RecycleRush.RobotMap;
import org.usfirst.frc2051.RecycleRush.commands.*;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class DriveSystem extends Subsystem
{
	SpeedController leftFront = RobotMap.driveSystemLeftFront;
	SpeedController leftRear = RobotMap.driveSystemLeftRear;
	SpeedController rightFront = RobotMap.driveSystemRightFront;
	SpeedController rightRear = RobotMap.driveSystemRightRear;
	RobotDrive mecanum = RobotMap.driveSystemMecanum;
	Encoder leftFrontEnc = RobotMap.driveSystemLeftFrontEnc;
	Encoder leftRearEnc = RobotMap.driveSystemLeftRearEnc;
	Encoder rightFrontEnc = RobotMap.driveSystemRightFrontEnc;
	Encoder rightRearEnc = RobotMap.driveSystemRightRearEnc;
	Ultrasonic ultrasonic = RobotMap.driveSystemUltrasonic;

	DriveGyro driveGyro = Robot.driveGyro;

	double rightStrafeDist;
	double leftStrafeDist;
	
	final double wheelRadiusIn = 4;
	final double wheelCircIn = 2 * Math.PI * wheelRadiusIn;
	final double tickPrRotationIn = 250 * wheelRadiusIn;
	final double inchPrTick = wheelCircIn / tickPrRotationIn;
	final double strafeInchPrTick = inchPrTick / 2.0; // rather wild guess
	
	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand()
	{
		// Set the default command for a subsystem here.
		setDefaultCommand(new DriveByJoystick());
	}

	/**
	 * Joystick deadband function that behaves consistently with positive and negative inputs
	 * Uses the curve f(x) = x ^ (1/x)
	 * Type this into Google Search to graph it: graph x^(1/x)
	 * Returns zero for values less than about 0.25, then scales up to return 1 for an input of 1
	 */
	private double deadBand(double x)
	{
		if (x > 0)
			return Math.pow(x, 1.0 / x);
		else if (x < 0)
			return -deadBand(-x);
		else
			return 0;
	}
	/**
	 * Joystick deadband function that behaves consistently with positive and negative inputs
	 * Uses the curve f(x) = x ^ (4/x)
	 * Type this into Google Search to graph it: graph x^(4/x)
	 * Returns zero for values less than about 0.5, then scales up to return 1 for an input of 1
	 */
	private double twistDeadBand(double x)
	{
		if (x > 0)
			return Math.pow(x, 4.0 / x);
		else if (x < 0)
			return -twistDeadBand(-x);
		else
			return 0;
	}

	public void takeJoystickInputs(Joystick driveStick)
	{
		// If the gyro is enabled, factor that into driving, else use a value of zero
		mecanum.mecanumDrive_Cartesian(driveStick.getX(), 
									   driveStick.getY(),
							  deadBand(driveStick.getZ()), 
				driveGyro.isGyroEnabled() ? driveGyro.getAngle() : 0.0);

		SmartDashboard.putNumber("Left Front Enc", leftFrontEnc.getDistance());
		SmartDashboard.putNumber("Left Rear Enc", leftRearEnc.getDistance());
		SmartDashboard.putNumber("Right Front Enc", rightFrontEnc.getDistance());
		SmartDashboard.putNumber("Right Rear Enc", rightRearEnc.getDistance());
	}

	public void stop()
	{
		mecanum.drive(0, 0);
	}

	// moves it
	public void moveIt(double speed)
	{
		mecanum.mecanumDrive_Cartesian(0, -speed, 0, driveGyro.getAngle());
	}

	/* Gets distance traveled since the last resetDist()
	 * when driving in the forward or backward direction
	 * where all wheels are turning in the same direction.
	 */
	public double getDistFwdBack()
	{
		return (rightRearEnc.getDistance() - rightStrafeDist) * inchPrTick;
	}
	
	public double getDistLeft()
	{
		return (leftRearEnc.getDistance() - leftStrafeDist) * strafeInchPrTick;
	}

	public double getDistRight()
	{
		return (rightRearEnc.getDistance() - rightStrafeDist) * strafeInchPrTick;
	}
	
	// resets distance
	public void resetDist()
	{
		rightStrafeDist = rightRearEnc.getDistance();
		leftStrafeDist = leftRearEnc.getDistance();
	}
}