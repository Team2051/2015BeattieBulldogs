// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2051.RecycleRush.subsystems;

import org.usfirst.frc2051.RecycleRush.Robot;
import org.usfirst.frc2051.RecycleRush.RobotMap;
import org.usfirst.frc2051.RecycleRush.commands.*;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.PIDSource.PIDSourceParameter;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class DriveSystem extends Subsystem
{
	SpeedController leftFront = RobotMap.driveSystemLeftFront;
	SpeedController leftRear = RobotMap.driveSystemLeftRear;
	SpeedController rightFront = RobotMap.driveSystemRightFront;
	SpeedController rightRear = RobotMap.driveSystemRightRear;
	RobotDrive mecanum = RobotMap.driveSystemMecanum;
	Encoder leftFrontEnc = RobotMap.driveSystemLeftFrontEnc;
	Encoder leftRearEnc = RobotMap.driveSystemLeftRearEnc;
	Encoder rightFrontEnc = RobotMap.driveSystemRightFrontEnc;
	Encoder rightRearEnc = RobotMap.driveSystemRightRearEnc;
	Ultrasonic ultrasonic = RobotMap.driveSystemUltrasonic;

	DriveGyro driveGyro = Robot.driveGyro;

	double bleh;

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand()
	{
		// Set the default command for a subsystem here.
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
		setDefaultCommand(new DriveByJoystick());
		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	}

	private double deadBand(double x)
	{
		// X^(1/1.75X)
		if (x > 0)
			return (Math.pow(x, 7.0 / (4.0 * x)));
		else if (x < 0)
			return -deadBand(-x);
		else
			return 0;
	}

	public void takeJoystickInputs(Joystick driveStick)
	{
		// If the gyro is enabled, factor that into driving, else use a value of zero
		mecanum.mecanumDrive_Cartesian(driveStick.getX(), 
				driveStick.getY(),
				deadBand(driveStick.getZ()), 
				driveGyro.isGyroEnabled() ? driveGyro.getAngle() : 0.0);

		SmartDashboard.putNumber("Left Front Enc", leftFrontEnc.getDistance());
		SmartDashboard.putNumber("Left Rear Enc", leftRearEnc.getDistance());
		SmartDashboard.putNumber("Right Front Enc", rightFrontEnc.getDistance());
		SmartDashboard.putNumber("Right Rear Enc", rightRearEnc.getDistance());
	}

	public void stop()
	{
		mecanum.drive(0, 0);
	}

	// moves it
	public void moveIt(double speed)
	{
		mecanum.mecanumDrive_Cartesian(0, -speed, 0, driveGyro.getAngle());
	}

	// gets distance
	public double getDist()
	{
		return rightRearEnc.getDistance() - bleh;
	}

	// resets distance
	public void resetDist()
	{
		bleh = rightRearEnc.getDistance();
	}
}