// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2051.RecycleRush.subsystems;

import org.usfirst.frc2051.RecycleRush.Robot;
import org.usfirst.frc2051.RecycleRush.RobotMap;
import org.usfirst.frc2051.RecycleRush.commands.*;
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class DriveSystem extends Subsystem
{
	SpeedController leftFront = RobotMap.driveSystemLeftFront;
	SpeedController leftRear = RobotMap.driveSystemLeftRear;
	SpeedController rightFront = RobotMap.driveSystemRightFront;
	SpeedController rightRear = RobotMap.driveSystemRightRear;
	RobotDrive mecanum = RobotMap.driveSystemMecanum;
	Encoder leftFrontEnc = RobotMap.driveSystemLeftFrontEnc;
	Encoder leftRearEnc = RobotMap.driveSystemLeftRearEnc;
	Encoder rightFrontEnc = RobotMap.driveSystemRightFrontEnc;
	Encoder rightRearEnc = RobotMap.driveSystemRightRearEnc;
	Ultrasonic ultrasonic = RobotMap.driveSystemUltrasonic;

	DriveGyro driveGyro = Robot.driveGyro;

	double initialRightRearEnc;
	double initialLeftRearEnc;

	final double wheelRadiusIn = 4;
	final double wheelCircIn = 2 * Math.PI * wheelRadiusIn;
	final double tickPrRotation = 250 * 4; // Encoder is k4X
	final double inchPrTick = wheelCircIn / tickPrRotation;
	final double strafeInchPrTick = inchPrTick / 2.0; // Wild guess

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand()
	{
		// Set the default command for a subsystem here.
		setDefaultCommand(new DriveByJoystick());
	}

	/**
	 * Joystick deadband function that behaves consistently with positive and
	 * negative inputs Uses the curve f(x) = x ^ (1/x) Type this into Google
	 * Search to graph it: graph x^(1/x) Returns zero for values less than about
	 * 0.25, then scales up to return 1 for an input of 1
	 */
	private double deadBand(double x)
	{
		if (x > 0)
			return Math.pow(x, 1.0 / x);
		else if (x < 0)
			return -deadBand(-x);
		else
			return 0;
	}

	/**
	 * Joystick deadband function that behaves consistently with positive and
	 * negative inputs Uses the curve f(x) = x ^ (4/x) Type this into Google
	 * Search to graph it: graph x^(4/x) Returns zero for values less than about
	 * 0.5, then scales up to return 1 for an input of 1
	 */
	private double twistDeadBand(double x)
	{
		if (x > 0)
			return Math.pow(x, 4.0 / x);
		else if (x < 0)
			return -twistDeadBand(-x);
		else
			return 0;
	}

	public void takeJoystickInputs(Joystick driveStick)
	{
		// If the gyro is enabled, factor that into driving, else use a value of
		// zero
		mecanum.mecanumDrive_Cartesian(deadBand(driveStick.getX()), deadBand(driveStick.getY()), twistDeadBand(driveStick.getZ()), driveGyro.isGyroEnabled() ? driveGyro.getAngle() : 0.0);

		SmartDashboard.putNumber("Left Front Enc", leftFrontEnc.getDistance());
		SmartDashboard.putNumber("Left Rear Enc", leftRearEnc.getDistance());
		SmartDashboard.putNumber("Right Front Enc", rightFrontEnc.getDistance());
		SmartDashboard.putNumber("Right Rear Enc", rightRearEnc.getDistance());
	}

	public void stop()
	{
		mecanum.stopMotor();
	}

	/**
	 *  moves it
	 * @param speed to move it
	 */
	public void moveIt(double speed)
	{
		mecanum.mecanumDrive_Cartesian(0, -speed, 0, driveGyro.isGyroEnabled() ? driveGyro.getAngle() : 0.0);
	}

	public void moveItSideLeft(double speed)
	{
		
	}
	
	public void moveItSideRight(double speed)
	{
		
	}
	
	/**
	 * Gets distance traveled since the last resetDist() when driving in the
	 * forward or backward direction where all wheels are turning in the same
	 * direction.
	 */
	public double getDistFwdBack()
	{
		return Math.abs(rightRearEnc.getDistance() - initialRightRearEnc) * inchPrTick;
	}

	/*
	 * Gets distance traveled since the last resetDist() when driving left
	 */
	public double getDistLeft()
	{
		return Math.abs(leftRearEnc.getDistance() - initialLeftRearEnc) * strafeInchPrTick;
	}

	/*
	 * Gets distance traveled since the last resetDist() when driving right
	 */
	public double getDistRight()
	{
		return Math.abs(rightRearEnc.getDistance() - initialRightRearEnc) * strafeInchPrTick;
	}

	// Resets distance
	public void resetDist()
	{
		initialRightRearEnc = rightRearEnc.getDistance();
		initialLeftRearEnc = leftRearEnc.getDistance();
	}

	public double autonSpeed(double maxSpeed, double finalDist, double currentDist)
	{
		final double rampSlope = ((1 - 0) / 12); // max speed minus min speed over target inches for slope.
		final double minSpeed = 0.25;

		double rampDist = (maxSpeed - minSpeed) / rampSlope;
	
		if(finalDist < rampDist)
			rampDist = finalDist / 2.0;
			
		if (currentDist <= rampDist) 												// if starting moving
			return (rampSlope * currentDist) + minSpeed; 							// begin acceleration
		else if (currentDist >= (finalDist - rampDist))								// if finishing moving
			return -rampSlope * (currentDist - (finalDist - rampDist))  + minSpeed; // begin deceleration
		else if (currentDist > rampDist && currentDist < (finalDist - rampDist)) 	// if moving
			return maxSpeed; 														// maintain coasting speed
		else																		// if error value
			return 0; 																// stop motors
	}
}